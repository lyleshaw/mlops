// Code generated by hertz generator.

package service

import (
	"context"
	"github.com/bytedance/gopkg/util/logger"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/lyleshaw/mlops/biz/dal/mysql"
	model "github.com/lyleshaw/mlops/biz/model/orm_gen"
	"github.com/lyleshaw/mlops/biz/model/service"
	"github.com/lyleshaw/mlops/biz/mw"
	"github.com/lyleshaw/mlops/biz/service/docker"
	"github.com/lyleshaw/mlops/pkg/constants"
	"net/http"
	"strconv"
)

// CreateApp .
// @router /api/v1/app [POST]
func CreateApp(ctx context.Context, c *app.RequestContext) {
	var err error
	var req service.CreateAppReq
	err = c.BindAndValidate(&req)
	if err != nil {
		logger.Errorf("create application bind error: %v", err)
		c.String(400, err.Error())
		return
	}

	user, exists := c.Get(mw.IdentityKey)
	if exists != true {
		logger.Errorf("create application get user error: %v", err)
		c.String(401, "unauthorized")
		return
	}

	port, err := mysql.GeneratePort()
	if err != nil {
		logger.Errorf("create application generate port error: %v", err)
		c.String(500, "internal server error")
		return
	}

	container, err := docker.StartDockerImage(ctx, req.AppImage, strconv.Itoa(port))
	if err != nil {
		logger.Errorf("create application start docker image error: %v", err)
		c.String(500, "internal server error")
		return
	}

	application, err := mysql.CreateApplication(ctx, req.AppName, port, req.AppImage, container.ID, int(user.(*model.User).UserID))
	if err != nil {
		logger.Errorf("create application create application error: %v", err)
		c.String(500, "internal server error")
		return
	}
	resp := &service.ApplicationResp{
		Code:    0,
		Message: "success",
		Data: &service.Application{
			AppID:    application.AppID,
			AppName:  application.AppName,
			AppPort:  application.AppPort,
			AppImage: application.AppImage,
			UserID:   user.(*model.User).UserID,
			CreateAt: application.CreateAt.Format(constants.TimeFormat),
			UpdateAt: application.UpdateAt.Format(constants.TimeFormat),
		},
	}
	c.JSON(200, resp)
}

// MyApp .
// @router /api/v1/app/me [GET]
func MyApp(ctx context.Context, c *app.RequestContext) {
	var req service.AllUserReq
	err := c.BindAndValidate(&req)
	if err != nil {
		logger.Errorf("myapp bind error: %v", err)
		c.String(400, err.Error())
		return
	}

	user, exists := c.Get(mw.IdentityKey)
	if exists != true {
		logger.Errorf("myapp user not exists")
		c.String(401, "unauthorized")
		return
	}
	apps, err := mysql.GetApplicationsByUserID(ctx, int(user.(*model.User).UserID))
	if err != nil {
		logger.Errorf("myapp get applications error: %v", err)
		c.String(500, "internal server error")
		return
	}

	// convert []*model.Application to []*service.Application
	var respApps []*service.Application
	for _, a := range apps {
		respApps = append(respApps, &service.Application{
			AppID:     a.AppID,
			AppName:   a.AppName,
			AppStatus: a.AppStatus,
			AppPort:   a.AppPort,
			AppImage:  a.AppImage,
			UserID:    a.UserID,
			CreateAt:  a.CreateAt.Format(constants.TimeFormat),
			UpdateAt:  a.UpdateAt.Format(constants.TimeFormat),
		})
	}

	resp := &service.AppListResp{
		Code:    0,
		Message: "success",
		Data:    respApps,
	}
	c.JSON(200, resp)
}

// AppInfo .
// @router /api/v1/app [GET]
func AppInfo(ctx context.Context, c *app.RequestContext) {
	var req service.AppInfoReq
	err := c.BindAndValidate(&req)
	if err != nil {
		logger.Errorf("application info bind error: %v", err)
		c.String(400, err.Error())
		return
	}

	user, exists := c.Get(mw.IdentityKey)
	if exists != true {
		logger.Errorf("application info user not exists")
		c.String(401, "unauthorized")
		return
	}
	application, err := mysql.GetApplicationByID(ctx, int(req.AppID))
	if err != nil {
		logger.Errorf("application info get application error: %v", err)
		c.String(500, "internal server error")
		return
	}
	if application.UserID != user.(*model.User).UserID {
		logger.Errorf("application does not belong to user")
		c.String(http.StatusForbidden, "application does not belong to user")
		return
	}
	resp := &service.ApplicationResp{
		Code:    0,
		Message: "success",
		Data: &service.Application{
			AppID:    application.AppID,
			AppName:  application.AppName,
			AppPort:  application.AppPort,
			AppImage: application.AppImage,
			UserID:   user.(*model.User).UserID,
			CreateAt: application.CreateAt.Format(constants.TimeFormat),
			UpdateAt: application.UpdateAt.Format(constants.TimeFormat),
		},
	}
	c.JSON(200, resp)
}

// UpdateApp .
// @router /api/v1/app [PATCH]
func UpdateApp(ctx context.Context, c *app.RequestContext) {
	var req service.UpdateAppReq
	err := c.BindAndValidate(&req)
	if err != nil {
		logger.Errorf("update application bind error: %v", err)
		c.String(400, err.Error())
		return
	}

	application, err := mysql.GetApplicationByID(ctx, int(req.AppID))
	if err != nil {
		logger.Errorf("update application get application error: %v", err)
	}

	user, exists := c.Get(mw.IdentityKey)
	if exists != true {
		c.String(401, "unauthorized")
		return
	}
	if user.(*model.User).UserID != application.UserID {
		logger.Errorf("update application user id does not match")
		c.String(http.StatusForbidden, "update application user id does not match")
		return
	}

	if req.IsReload {
		_, err = docker.ReloadDockerImage(ctx, application.DockerID, *req.AppImage, string(application.AppPort))
		if err != nil {
			logger.Errorf("update application reload docker image error: %v", err)
			c.String(500, "internal server error")
			return
		}
	}

	application, err = mysql.UpdateApplicationByID(ctx, int(req.AppID), req.AppName, req.AppImage)
	if err != nil {
		logger.Errorf("update application update application error: %v", err)
		c.String(500, "internal server error")
		return
	}
	resp := &service.ApplicationResp{
		Code:    0,
		Message: "success",
		Data: &service.Application{
			AppID:    application.AppID,
			AppName:  application.AppName,
			AppPort:  application.AppPort,
			AppImage: application.AppImage,
			UserID:   user.(*model.User).UserID,
			CreateAt: application.CreateAt.Format(constants.TimeFormat),
			UpdateAt: application.UpdateAt.Format(constants.TimeFormat),
		},
	}
	c.JSON(200, resp)
}

// DeleteApp .
// @router /api/v1/app [DELETE]
func DeleteApp(ctx context.Context, c *app.RequestContext) {
	var req service.DeleteAppReq
	err := c.BindAndValidate(&req)
	if err != nil {
		logger.Errorf("delete application bind error: %v", err)
		c.String(400, err.Error())
		return
	}

	application, err := mysql.GetApplicationByID(ctx, int(req.AppID))
	if err != nil {
		logger.Errorf("delete application get application error: %v", err)
		c.String(500, "internal server error")
		return
	}

	user, exists := c.Get(mw.IdentityKey)
	if exists != true {
		c.String(401, "unauthorized")
		return
	}
	if user.(*model.User).UserID != application.UserID {
		logger.Errorf("delete application user id does not match")
		c.String(http.StatusForbidden, "delete application user id does not match")
		return
	}

	err = docker.StopDockerImage(ctx, application.DockerID)
	if err != nil {
		logger.Errorf("delete application stop docker image error: %v", err)
		c.String(500, "internal server error")
		return
	}

	err = mysql.DeleteApplicationByID(ctx, int(req.AppID))
	if err != nil {
		logger.Errorf("delete application delete application error: %v", err)
		c.String(500, "internal server error")
		return
	}
	resp := &service.BaseResp{
		Code:    0,
		Message: "success",
	}
	c.JSON(200, resp)
}
